\documentclass[a4paper,11pt]{article}

\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage{color}
\usepackage{microtype}
\usepackage{graphicx}
\usepackage{booktabs}  % For better tables
\usepackage{enumitem}  % For better lists
\usepackage{hyperref}  % For clickable links in PDF
\usepackage{amsmath}  % Pour les équations
\usepackage[margin=2cm]{geometry}
\usepackage[skip=2pt]{caption}
\setlength{\abovedisplayskip}{3pt}
\setlength{\belowdisplayskip}{3pt}

\usepackage{listings}

\lstset{
    language=C,
    basicstyle=\ttfamily\small,           
    frame=single,
    breaklines=true,                       
}

\hypersetup{colorlinks=true,linkcolor=blue,urlcolor=red,citecolor=green}


\pagestyle{fancy}
\setlength{\headheight}{29pt}

\usepackage{titlesec}


\lhead{\includegraphics[width=2cm]{./img/image.png}}
\rhead{\includegraphics[width=2cm]{./img/claude.png}}

\begin{document}

\title{\huge{\textbf{\textcolor{blue}{Lo Poti Donjon}}}}
\author{\Large{Ubissauphte}}
\date{\today}
\maketitle
\newpage
\tableofcontents
\newpage

\section{Introduction}
\subsection{Contexte du projet}
\subsection{Présentation du projet}

\textbf{Lo Poti Donjon} est un projet ambitieux que nous, Ubissauphte, avons lancé le 13 janvier 2025. Initialement, nous envisagions de créer 
un jeu de bataille navale en ligne. Cependant, après plusieurs réunions au sein du groupe, nous avons décidé de revoir notre approche. 

L'idée de créer un jeu plus complexe avec une patte graphique plus importante a vraiment stimulé notre créativité.

Nous avons donc décidé de créer un jeu roguelike, un sous-genre de jeu de rôle où le joueur explore 
un donjon rempli de monstres qu'il doit combattre pour gagner de l'expérience et des trésors. Notre jeu présente certains avantages et défauts :

\begin{center}
\begin{tabular}{p{5cm}|p{5cm}}
\toprule
\textbf{Avantages} & \textbf{Inconvénients} \\
\midrule
Facile d'accès & Potentiellement addictif \\
Permissif & Aspects punitifs \\
Fluidité optimisée & \\
Portage sur diverses machines & \\
Évolution constante du personnage & \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Conception}
\newpage

\section{Organisation du projet}
\textit{Cette partie traite des moyens organisationnels mis en œuvre permettant la réalisation du projet.}

\subsection{Répartition des tâches}

Concernant la répartition des tâches, nous nous sommes appuyés sur les qualités de chacun pour avancer rapidement et efficacement :

\begin{itemize}[leftmargin=*]
  \item \textbf{Victore Fombertasse} a réalisé les animations du jeu ainsi que l'audio et la création de la structure d'un niveau.
  
  \item \textbf{Souleymane Barry} a créé le système d'inventaires, celui de sauvegarde ainsi que le prototype du système de déplacement du joueur.
  
  \item \textbf{Baptiste Carfantan} a conçu les salles générées procéduralement ainsi que la boucle de gameplay pour progresser dans le jeu.
  
  \item \textbf{Barthélemy Deroualt}, chef de projet, s'est chargé de la gestion des systèmes liés aux ennemis, au joueur, aux événements ainsi qu'à la physique du jeu.
\end{itemize}

Nous avons également réalisé des tâches en groupe, que ce soit pour intégrer les codes au programme principal ou pour traiter des problèmes suffisamment complexes nécessitant la participation de plusieurs personnes. Nous avons par exemple développé des systèmes de simplification de code, appelés « managers », permettant à chaque membre de l'équipe d'utiliser les fonctionnalités sans avoir besoin de comprendre entièrement le code des autres.

\subsection{Planning prévisionnel}

\subsection{Outils de travail}


\newpage
\section{Développement}

\subsection{Génération aléatoire du donjon}
\textit{Cette partie traite de la géneration procédurale d'un niveau du jeu.}
\subsubsection{La géneration aléatoire de la structure du donjon}

\subsubsection{La géneration aléatoire des salles}
Lorsqu'on parle d'aléatoire en infromatique on à deux façons de voir la chose. Soit du \guillemotleft pur\guillemotright \ aléatoire appelé \textbf{noise}, c'est-à-dire qu'on met une probabilité fixe, si elle arrive, on met un mur sinon on met un sol. Le problème avec cette méthode est qu'elle n'est pas adapté pour un rogue-like car elle ne garantit pas que le niveau soit jouable (pouvoir accéder à toutes les salles). 
La deuxième façon de faire de l'aléatoire est de faire de l'aléatoire contrôlé appelé gradient noise, c'est à dire de créer une continuité dans l'aléatoire pour que ça fasse plus naturelle.\\\\

Nous avons donc choisi cette deuxième option en utilisant l'algorithme de perlin noise (ou bruit de Perlin en français ) qui est une texture procédurale primitive utilisée pour augmenter le réalisme de l'environnement de jeux par exemple Minecraft utilise du Perlin noise.\\
Le Perlin noise repose sur trois étapes reposant sur des principes mathématiques et physiques. Tout d'abord il faut générer une matrice de dimension n. Pour chaque case de cette matrice, on va attribuer un champ de vecteurs normaux aléatoire.\\
Puis nous devons ensuite calculer le produit scalaire pour chaque case entre le vecteur normal et le vecteur distance qui est un vecteur représentant la side identique pour chaque case changent à chaque génération de salle.\\
Enfin, nous devons calculer l'interpolation entre les vecteurs calculés dans la case, qui, renvoie 0 si le noeud est évalué sur lui-même. Cette étape sert à adoucir la transition entre les valeurs aléatoires générées. Sans elle, le résultat serait trop brut.\\
\[
f(x) = a_{0} + \text{smoothstep}(x) \cdot (a_{1} - a_{0}), \quad \text{pour } 0 \leq x \leq 1
\]
\begin{equation*}
\text{smoothstep}(x) =
S_1(x) =
\begin{cases} 
0, & x \leq 0 \\ 
3x^2 - 2x^3, & 0 < x < 1 \\ 
1, & x \geq 1
\end{cases}
\end{equation*}
Après toutes c'est étapes, nous obtenons une matrice de bruit de perlin qui quand on l'affiche en modifiant certains paramètres comme la limite on obtient:\
\begin{figure}[ht]
\centering
\includegraphics[width=0.4\textwidth]{./img/perlin.jpg}
\caption{affichage du perlin noise}
\label{fig:affichage perlin}
\end{figure}
\\\\
Si on lisse le perlin noise et qu'on rajoute des tiles pour les valeurs et en mettant des bordures sur le côté pour empêcher le joueur de sortir de la carte on obtient ceci:\\
\begin{figure}[h]
\centering
\includegraphics[width=0.4\textwidth]{./img/perlinLisser.png}
\caption{affichage du perlin noise lisser}
\label{fig:affichage perlin lisser}
\end{figure}
\\
 On remarque que la salle a quelques problèmes. Le premier problème est que l'on peut voir en haut à droite de la \autoref{fig:affichage perlin lisser} un trou inaccessibles qui peut s'avérer être problématique si il y a un coffre dedans, de plus la salle n'est pas très belle et nous ne pouvons pas sortir de la salle.
\\\\
 Pour régler le problème du trou nous avons utilisé un algorithme d'écoulemenent par bloc, c'est à dire qu'on prend une case qui est vide on lui assigne une valeur et tant que ses voisines sont vides, on met la valeur de ces cases à la même valeur que la case initiale et on recommence tant qu'on peut propager la valeur. 
 On répète ainsi l'opération tant qu'il reste une case vide en augmentant la valeur de +1. 
 Quand tous les blocs sont assignés on compte le nombre de cases contenu dans le bloc et puisque la génération ne crée pas de petit couloir tous indépendants, si on prend le plus grand bloc alors nous sommes sûrs d'avoir un terrain ouvert où le joueur peut se déplacer. 
 Quand on a identifié le plus grand bloc, il nous reste plus qu'à combler les autres. 
 Ainsi, tous les espaces de la salle sont atteignables par le joueur.
 \\\\
Pour créer des sorties de la salle il suffit de prendre la structure de celle-ci générée lors de la création du niveau, regarder si cette salle est liée à une autre salle et si oui dans quelle direction ? 
Quand on a pris l'information, on prend une case aléatoirement sur la première ou dernière ligne ou colonne suivant la salle liée à la salle qu'on crée. 
Puis on se place sur une extrémité choisie aléatoirement de la ligne ou de la colonne et on \guillemotleft casse \guillemotright \ la case puis on recommence sur les cases dans le même alignement que la case d'origine tant qu'on n'a pas accès au terrain de jeux du joueur.
Enfin on place un téleporteur sur la case d'origine pour pouvoir changer de salle.
\\\\
Enfin, pour rendre la salle plus jolie il suffit de faire des règles de génerations pour assigner un tiles en fonction de la situation de la case. Par exemple si les voisins direcst de la case (gauche,haut,droit,et bas) sont vides, alors l'algorithme place un élément de décoration.\\
Si on fait seulement cela, on est sûr d'avoir des problèmes sur une case respectant deux situations et donc avoir deux tiles. Dans cette situation il ne prend qu'un tiles ce qui fait que ça crée des bugs visuelles. On va donc utiliser un algorithme de lissage permettant de régler ce problème à 95%.
\\\\
Quand tous ces changement sont appliqués, on insère un facteur aléatoire dans la génération de la carte (le vecteur de direction) pour que chaque salle soit différente les unes des autres et on obtient : 

\begin{figure}[h]
\centering
\includegraphics[width=0.4\textwidth]{./img/SalleFinal.png}
\caption{affichage d'une salle génerer de façon procédural}
\label{fig:affichage de la salle final}
\end{figure}

 

\subsection{Gestion des items}

\subsection{Le moteur physique}



\subsubsection{Pourquoi un moteur physique ?}
\label{sec:moteur_physique}

Dans un jeu vidéo, et particulièrement dans un \textbf{rogue-like}, les interactions entre éléments (personnages, ennemis, objets) posent un défi de taille~: l'imprévisibilité des combinaisons de collisions. 

Les mouvements, les collisions, les rebonds et autres effets physiques doivent être simulés de manière réaliste pour ne pas gâcher l’expérience du joueur. Cependant, un système simplifié, où chaque interaction serait codée manuellement, devient rapidement ingérable, la solution que nous avons donc trouver est celle d'un \textbf{moteur physique}, permettant de gérer de manière automatisée toutes ces interactions.


\subsubsection{Gestion des collisions par colliders} 
\label{sec:colliders}
La détection des collisions repose sur une abstraction géométrique des entités. Plutôt que de calculer les intersections \textit{pixel par pixel} -- méthode particulièrement coûteuse en ressources -- chaque élément est associé à un volume primitif. Cette approche répond à trois exigences fondamentales du projet~:

\begin{itemize}
    \item Maintenir un coût de calcul raisonnable.
    \item Garantir des comportements physiques prévisibles.
    \item Faciliter l'extension du système par modularité.
\end{itemize}

\paragraph{Implémentation technique} 
Chaque entité se voit attribuer un composant physique optionnel accompagné d'une forme primitive adaptée à sa nature~:
\begin{itemize}
    \item \textbf{Cercles} pour les éléments arrondis (tonneaux, ennemis, joueur).
    \item \textbf{Rectangles} pour les structures angulaires (caisses, murs).
\end{itemize}
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.75\linewidth]{./img/debugCollider.png}
    \caption{Visualisation des colliders (en rouge) sur différentes entités}
    \label{fig:colliders_exemple}
\end{figure}

\paragraph{Exemple d'utilisation} 
Le joueur, initialement modélisé par un rectangle de \(16 \times 16\)~px, a été remplacé par un cercle de \(16\)~px de diamètre. Cette modification~:
\begin{itemize}
    \item Procure une sensation de mouvement plus naturelle.
    \item Permet un glissement le long des surfaces.
    \item Génère des rebonds cohérents dans les coins.
\end{itemize}



\paragraph{Exemple d'interaction}  
Lorsqu’un Slime (léger et élastique) est frappé par le joueur, une force orientée selon l’angle de l’attaque lui est appliquée. Projeté contre un Orc (lourd), le moteur calcule automatiquement la réaction : l’Orc subit un léger recul, tandis que le Slime rebondit en changeant de direction. Si le Slime percute ensuite un mur, son élasticité réduit progressivement l’énergie du rebond. Enfin, il peut se cogner contre un autre slime, et lui transmettre encore de l’énergie. Ces interactions en cascade émergent naturellement des lois physiques configurées, sans nécessiter de code spécifique.

\paragraph{Avantages}  
Ce système réduit significativement la complexité du code. Par exemple, une épée qui repousse un ennemi utilise la même logique qu’un projectile ricochant sur un mur, grâce aux paramètres centralisés. Il offre également une extensibilité aisée : ajouter une entité (comme un projectile) se limite à définir ses constantes physiques.

\subsection{Les ennemis}

\subsection{Le cycle de jeu}

\section{Bilan et conclusions}

\section{Annexes}

\subsection{Exemple de débogage : Gestion des pointeurs \texttt{NULL} selon le système d'exploitation}
\subsubsection{Contexte du problème}
Lors de l'exécution du programme, une \textbf{erreur de segmentation} a été observée. Curieusement, ce comportement ne se manifestait que sur certaines machines de l'équipe, tandis que d'autres pouvaient exécuter le jeux sans problème. 
L'origine du bug etait dans la tentative de conversion d'un pointeur \texttt{NULL}, retourné par la fonction \texttt{getObject} pour un index invalide, en un pointeur d'un autre type

\subsubsection{Investigation initiale}
A force de test nous sommes arrivé à la conclusion que :
\begin{itemize} 
    \item Les paramètres d'entrée étaient vérifier, et non égale à \texttt{NULL}. 
    \item Deux éléments étaient suspectés d'être en cause : 
    \begin{itemize} \item La variable \texttt{salleDep} dans le contrôleur de scène 
    \item La structure de données \texttt{scene} 
    \end{itemize} 
\end{itemize}

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{./img/gdbSIGEGV.png}
\caption{Trace d'exécution dans GDB montrant le point de crash}
\label{fig:gdbSIGEGV}
\end{figure}

\newpage
L'analyse à l'aide de GDB a permis d'observer : 
\begin{itemize} 
    \item Une adresse mémoire non nulle (ex. \texttt{0x01}) pour \texttt{salleDep}, même dans le cas où \texttt{getObject} devait renvoyer \texttt{NULL}. 
    \item Une variation aléatoire de la valeur de \texttt{salleDep} entre différentes exécutions et machine (\textit{voir Fig. \ref{fig:gdb0x1}})
\end{itemize}

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{./img/gdb0xf0.png}
\caption{Sortie de \texttt{print salleDep} montrant une adresse invalide}
\label{fig:gdb0xf0}
\end{figure}

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{./img/gdb0x1.png}
\caption{Variation de la valeur de \texttt{salleDep} entre deux exécutions}
\label{fig:gdb0x1}
\end{figure}

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{./img/gdbNoError.png}
\caption{Comportement normal lorsque tout marche}
\label{fig:gdbNoError}
\end{figure}

\subsubsection{Origine du problème et correction du code}

\begin{lstlisting}[caption={Ligne fautive}, label=code:fautive]
t_scene* salleDep = (t_scene*)getObject(controller->scene, controller->currentScene);
\end{lstlisting}

Le problème venait de la tentative de conversion d'un pointeur \texttt{NULL}, retourné par la fonction \texttt{getObject} lorsqu'un indice invalide (Dans notre cas, \texttt{-1}) était utilisé.
Nous avons théorisé que en raison des différences d'initialisation de la mémoire entre systèmes d'exploitation, certains environnements interprétaient correctement ce retour comme étant \texttt{NULL}, tandis que d'autres ne le faisaient pas, générant ainsi des valeurs indéterminées (par exemple : \texttt{0x01}, \texttt{0xf0}), pouvant inclure \texttt{NULL}, ne facilitant pas le debuggage.

\end{document}