\documentclass[a4paper,11pt]{article}

\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage{color}
\usepackage{microtype}
\usepackage{graphicx}
\usepackage{booktabs}  % For better tables
\usepackage{enumitem}  % For better lists
\usepackage{hyperref}  % For clickable links in PDF
\usepackage{amsmath}  % Pour les équations
\usepackage[margin=2cm]{geometry}
\usepackage[skip=2pt]{caption}
\setlength{\abovedisplayskip}{3pt}
\setlength{\belowdisplayskip}{3pt}

\usepackage{listings}

\lstset{
    language=C,
    basicstyle=\ttfamily\small,           
    frame=single,
    breaklines=true,                       
}

\hypersetup{colorlinks=true,linkcolor=blue,urlcolor=red,citecolor=green}


\pagestyle{fancy}
\setlength{\headheight}{29pt}

\usepackage{titlesec}


\lhead{\includegraphics[width=2cm]{./img/image.png}}
\rhead{\includegraphics[width=2cm]{./img/claude.png}}
\chead{Lo Poti Donjon}

\begin{document}

\title{\huge{\textbf{\textcolor{blue}{Lo Poti Donjon}}}}
\author{\Large{Ubissauphte}}
\date{\today}
\maketitle

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\linewidth]{./img/pablo.png}
\label{fig:map_gen32}
\end{figure}
\bigskip
\newpage
\tableofcontents
\newpage

\section{Introduction}
\subsection{Contexte du projet}

Pour notre projet de fin d'année en L2 informatique, nous devons réaliser un jeu vidéo de notre choix suivant quelques contraintes imposées :

\begin{itemize}
    \item utilisation de la librairie SDL
    \item contraintes de temps (4 mois)
\end{itemize}
En plus de nous former, ce projet nous demande d'approfondir nos connaissances personnelles ainsi que de se familiariser avec les travaux de groupes.\\
En effet, pour réaliser ce projet nous n'étions pas groupes de 3 ou 4, nous devions donc nous organiser, réfléchir ainsi que travailler ensemble pour un objectif commun.


\subsection{Présentation du projet}

\textbf{Lo Poti Donjon} est un projet ambitieux que nous, Ubissauphte, avons lancé le 13 janvier 2025. Initialement, nous envisagions de créer un jeu de bataille navale en ligne. Cependant, après plusieurs réunions au sein du groupe, nous avons décidé de revoir notre approche. 

L'idée de créer un jeu plus complexe avec une patte graphique plus importante a vraiment stimulé notre créativité.

Nous avons donc décidé de créer un jeu roguelike, un sous-genre de jeu de rôle où le joueur explore 
un donjon rempli de monstres qu'il doit combattre pour gagner de l'expérience et des trésors. Notre jeu présente certains avantages et défauts :

\begin{center}
\begin{tabular}{p{5cm}|p{5cm}}
\toprule
\textbf{Avantages} & \textbf{Inconvénients} \\
\midrule
Facile d'accès & Potentiellement addictif \\
Permissif & Aspects punitifs \\
Fluidité optimisée & \\
Portage sur diverses machines & \\
Évolution constante du personnage & \\
\bottomrule
\end{tabular}
\end{center}

Ce qui rend ce jeu unique, c'est son aspect imprévisible, grâce à une génération totalement aléatoire. Le design des cartes et le nombre d'ennemis que l'on rencontre sont impossible à anticiper. Chaque carte représente un environnement dans lequel le joueur évolue, et toutes les cartes sont générées aléatoirement sous forme de donjons, eux-mêmes générant un nombre aléatoire de cartes. Une fois que tous les ennemis ont été éliminés, le joueur débloque une nouvelle carte, différente de la précédente, qui le conduira jusqu'au boss final.

\subsection{Conception}

\section{Organisation du projet}
\textit{Cette partie traite des moyens organisationnels mis en œuvre permettant la réalisation du projet.}

\subsection{Répartition des tâches}


Concernant la répartition des tâches, nous nous sommes appuyés sur les qualités de chacun pour avancer rapidement et efficacement :


\begin{itemize}[leftmargin=*]
  \item \textbf{Victore Fombertasse} a réalisé les animations du jeu ainsi que l'audio et la création de la structure d'un niveau.
  \item \textbf{Souleymane Barry} a créé le système d'inventaires, celui de sauvegarde ainsi que le prototype du système de déplacement du joueur.
  \item \textbf{Baptiste Carfantan} a conçu les salles générées procéduralement ainsi que la boucle de gameplay pour progresser dans le jeu.Lors de nos premières réunions, nous devions réaliser un planning prévisionnel pour organiser et répartir les tâches à accomplir, voici donc le planning convenu:
  \item \textbf{Barthélemy Deroualt}, chef de projet, s'est chargé de la gestion des systèmes liés aux ennemis, au joueur, aux événements ainsi qu'à la physique du jeu.
\end{itemize}

Nous avons également réalisé des tâches en groupe, que ce soit pour intégrer les codes au programme principal ou pour traiter des problèmes suffisamment complexes nécessitant la participation de plusieurs personnes. Nous avons par exemple développé des systèmes de simplification de code, appelés « managers », permettant à chaque membre de l'équipe d'utiliser les fonctionnalités sans avoir besoin de comprendre entièrement le code des autres.

\subsection{Planning prévisionnel}

Lors de nos premières réunions, nous devions réaliser un plannign prévisionnel pour organiser et répartir les ta^ches à acomplir, voici donc le planning convenus:

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\linewidth]{./img/diagrmmePrevus.png}
\caption{diagramme de Gant Prévus}
\label{fig:map_gen32}
\end{figure}
\bigskip
Malheureusement, des imprévus sur certains points nous ont forcées à ne pas respecter ce planning sur certains points, en faisant plusieurs tâches en même temps et retouches sur certaines parties du code dues à des problèmes découverts lors de nos divers tests du jeu. Voici donc le diagramme de Gantt réel

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\linewidth]{./img/diagramme réel.png}
\caption{diagramme de Gant Réel}
\label{fig:map_gen32}
\end{figure}
\bigskip





\newpage
\section{Développement}

\subsection{Génération aléatoire du donjon}
\textit{Cette partie traite de la géneration procédurale d'un niveau du jeu.}
\subsubsection{La géneration aléatoire de la structure du donjon}

Le donjon est généré sous forme de graphe où chaque nœud représente une salle. L'algorithme garantit :

    Une connectivité entre toutes les salles

    La possibilité d'avoir plusieurs salles reliées à une seule

    L'ajout de salles spéciales (marchand, boss) déjà prédéfini 
\\\\
\textbf{Processus de génération}
\begin{itemize}
    \item Initialisation : Création d'une salle racine (point de départ)
    \item Expansion aléatoire : Ajout itératif de salles dans des directions libres (haut/bas/gauche/droite)
    \item Contrôle des collisions : Vérification des superpositions via u système de coordonnées en grille
    \item Post-traitement : Insertion des salles spéciales à partir du graphe principal
\end{itemize}

\begin{figure}[h]
\centering
\includegraphics[width=0.4\linewidth]{./img/map_generation.png}
\caption{Exemple de sortie du générateur avec visualisation des connexions}
\label{fig:map_gen32}
\end{figure}
\bigskip
Transformer le graphe en représentation jouable :
\begin{itemize}
    \item Redimensionnement de l'affichage par rapport  au nombre de salles (grandeur des carrés affiché, centralisation vers la partie gauche de l'écran)
    \item  Placement automatique des icônes spéciales (boss en violet, marchand en vert, joueur en jaune)
\end{itemize}
\bigskip
Optimisation:
\begin{itemize}
\item \textbf{Challenge technique} : Certaines salles pouvaient se générer au même endroit, ce qui les faisait se superposer
\item \textbf{Solution} : On empêche les salles de se superposer en testant leur position avec les autres avant de les ajouter
\end{itemize}


\subsubsection{La géneration aléatoire des salles}
Lorsqu'on parle d'aléatoire en informatique on à deux façons de voir la chose. Soit du \guillemotleft pur\guillemotright \ aléatoire appelé \textbf{noise}, c'est-à-dire qu'on met une probabilité fixe, si elle arrive, on met un mur sinon on met un sol. Le problème avec cette méthode est qu'elle n'est pas adaptée pour un rogue-like car elle ne garantit pas que le niveau soit jouable (pouvoir accéder à toutes les salles). 
La deuxième façon de faire de l'aléatoire est de faire de l'aléatoire contrôlé appelé gradient noise, c'est à dire de créer une continuité dans l'aléatoire pour obtenir un résultat plus naturel.\\\\

Nous avons donc choisi cette deuxième option en utilisant l'algorithme de Perlin noise (ou bruit de Perlin en français ) qui est une texture procédurale  utilisée pour générer un environnement de jeux, . nous pouvons citer comme exemple le jeu Minecraft qui utilise cet algorithme.\\
Le Perlin noise est constitué de trois étapes reposant sur des principes mathématiques et physiques. Tout d'abord il faut générer une matrice de dimension n. Pour chaque case de cette matrice, on va attribuer un champ de vecteurs normaux aléatoires.\\
Puis nous devons calculer,pour chaque case, le produit scalaire entre le vecteur normal et le vecteur distance qui est un vecteur représentant le facteur aléatoire, identique pour chaque case, changant à chaque génération de salle.\\
Enfin, nous devons calculer l'interpolation entre les vecteurs calculés dans la case. Cette étape sert à adoucir la transition entre les valeurs aléatoires générées. Sans elle, le résultat serait trop brut.\\
\[
f(x) = a_{0} + \text{smoothstep}(x) \cdot (a_{1} - a_{0}), \quad \text{pour } 0 \leq x \leq 1
\]
\begin{equation*}
\text{smoothstep}(x) =
S_1(x) =
\begin{cases} 
0, & x \leq 0 \\ 
3x^2 - 2x^3, & 0 < x < 1 \\ 
1, & x \geq 1
\end{cases}
\end{equation*}
Après toutes ces étapes, nous obtenons une matrice de bruit de Perlin pour laquelle on obtient l'affichage suivant en modifiant certains paramètres comme la limite:\
\begin{figure}[h]
\centering
\includegraphics[width=0.4\textwidth]{./img/perlin.jpg}
\caption{affichage du perlin noise}
\label{fig:affichage perlin}
\end{figure}
\\\\
\newpage
Si on lisse le Perlin noise et qu'on rajoute des tiles pour les valeurs et en mettant des bordures sur le côté pour empêcher le joueur de sortir de la carte on obtient ceci:\\

\begin{figure}[h]
\centering
\includegraphics[width=0.4\textwidth]{./img/perlinLisser.png}
\caption{affichage du Perlin noise lissé}
\label{fig:affichage perlin lisser}
\end{figure}
\bigskip
On remarque que la salle a quelques problèmes. Le premier problème est que l'on peut voir en haut à droite de la \autoref{fig:affichage perlin lisser} un trou inaccessibles qui peut s'avérer être problématique s'il y a un coffre dedans, de plus la salle n'est pas très belle et nous ne pouvons pas en sortir.
\\\\

 Pour régler le problème de trou : 
 \begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{./img/ecoulementBloc.png}
    \caption{écoulemenent par bloc}
    \label{fig:exemple ecoulement}
\end{figure}

principe de l'algorithme d'écoulemenent par bloc: 
\begin{itemize}
    \item On prend une case, on lui assigne une valeur et tant que ses voisines sont vides, on met la valeur de ces cases à la même valeur que la case initiale et on recommence tant qu'on peut propager la valeur.
    \item On cherche le bloc avec le plus grand nombre de case
    \item Quand on a identifié le plus grand bloc, il ne nous reste plus qu'à combler les autres.
\end{itemize}
\bigskip




\bigskip

Pour rendre la salle plus jolie il suffit de faire des règles de géneration pour assigner un tiles en fonction de la situation de la case. Par exemple si les voisins directs de la case (gauche,haut,droit,et bas) sont vides, alors l'algorithme place un élément de décoration.\\
Si on fait seulement cela, on est sûr d'avoir des problèmes sur une case respectant deux situations et donc avoir deux tiles. Dans cette situation elle ne prend qu'un tiles ce qui fait que ça crée des bugs visuels. On va donc utiliser un algorithme de lissage permettant de régler ce problème à 95\%.
\newpage
Enfin, pour créer des sorties de la salle:
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{./img/placementSortie.png}
    \caption{placement de sortie}
    \label{fig:exemple placement de sorties}
\end{figure}

Principe de fonctionnement:
\begin{itemize}
    \item Regarder si cette salle est liée à une autre salle et si oui dans quelle direction ?
    \item Prendre une case aléatoirement sur la première ou dernière ligne ou colonne suivant la salle liée à la salle qu'on crée. 
    \item \guillemotleft Casser \guillemotright \ la case puis recommencer sur les cases dans le même alignement que la case d'origine tant qu'il n'y a pas d'accès au terrain de jeu du joueur.
    \item Placer un téleporteur sur la case d'origine pour pouvoir changer de salle.
\end{itemize}

\bigskip
Quand tous ces changement sont appliqués, on insère un facteur aléatoire dans la génération de la carte (le vecteur de direction) pour que chaque salle soit différente les unes des autres et on obtient : 

\begin{figure}[h]
\centering
\includegraphics[width=0.4\textwidth]{./img/SalleFinal.png}
\caption{affichage d'une salle génerée de façon procédurale}
\label{fig:affichage de la salle final}
\end{figure}


\newpage

\subsection{Gestion des items}


Nous avons choisi d'utiliser un système de sauvegarde et de chargement de fichiers contenant des blocs, chacun composé d'une liste de clés et de valeurs. Ces clés et valeurs sont ensuite stockées dans des structures grâce au programme de chargement, ce qui nous permet d'enregistrer les inventaires des joueurs.\

\begin{center} 
Comment cela fonctionne-t-il ? 
\end{center} Tout d'abord, les données relatives aux objets sont enregistrées dans un fichier texte, puis ces données sont injectées dans les structures correspondantes. Une fois les données utilisées et modifiées, nous pouvons les récupérer en les sauvegardant dans un nouveau fichier texte.

\begin{figure}[h]
    \centering 
    \includegraphics[width=1\linewidth]{./img/systemeSauvegarde.png} 
    \caption{Système de sauvegarde} 
    \label{fig:sauvegarde} 
\end{figure}
 

Nous avons créé une interface d'inventaire permettant d'accéder aux différents objets collectés au cours de la partie. Elle s'adapte automatiquement à la taille de l'écran, offrant ainsi un affichage agréable pour les joueurs.

\begin{figure}[h] 
    \centering 
    \includegraphics[width=0.4\linewidth]{./img/inventaire.png} 
    \caption{Inventaire} 
\end{figure} Grâce à l'intégration de boutons, l'interface possède plusieurs fonctionnalités :

   - Placement des objets dans les slots en fonction de leur type.

\begin{figure}[h]
    \centering 
    \includegraphics[width=0.2\linewidth]{./img/itemslot.png} 
    \caption{Inventaire : slot d'objet} 
\end{figure}

   - Affichage des statistiques et de la description en fonction de l'objet sur lequel on clique (voir \autoref{fig:inventaire}).


\newpage

\subsection{Le moteur physique}

\subsubsection{Pourquoi un moteur physique ?}
\label{sec:moteur_physique}
Dans un jeu vidéo, et particulièrement dans un \textbf{rogue-like}, les interactions entre éléments (personnages, ennemis, objets) posent un défi de taille~: l'imprévisibilité des combinaisons de collisions. \\
Les mouvements, les collisions, les rebonds et autres effets physiques doivent être simulés de manière réaliste pour ne pas gâcher l’expérience du joueur. Cependant, un système simplifié, où chaque interaction serait codée manuellement, devient rapidement ingérable, la solution que nous avons donc trouver est celle d'un \textbf{moteur physique}, permettant de gérer de manière automatisée toutes ces interactio

\subsubsection{Composant Physique}
\label{sec:structure_donnees}
Dans notre moteur de jeu, chaque entité est doté de \textbf{composant}, le composant \texttt{physic} permet de doter (ou non) une entité de propriétés influençant ses interactions avec d’autres objets :
\begin{itemize}
    \item \texttt{velocity} : Vecteur de vitesse en pixels/seconde
    \item \texttt{mass} : Masse
    \item \texttt{friction} : Coefficient de frottement
    \item \texttt{restitution} : Élasticité des collisions
\end{itemize}

Ces propriétés physiques suffisent à gérer toute sorte de situations sans nécessité des règles prédéfinis.

\paragraph{Slime qui subit une attaque}
Lorsqu’un joueur frappe un Slime, la force appliquée le projette en arrière. Léger et élastique, il rebondit sur le sol et glisse légèrement si la friction est faible. S’il percute un mur, il rebondit en perdant de l’énergie à chaque impact. En heurtant un autre Slime, ils absorbent et redistribuent leur énergie, créant une réaction en chaîne.

\paragraph{Orc qui subit une attaque}
Face à un Orc, bien plus massif et peu élastique, l’impact le fait à peine reculer, tandis que le joueur subit lui un léger recul.

\subsubsection{Colliders}
\label{sec:colliders}
Sans détection des collisions, aucune interaction n'est possible. Pour rebondir, glisser ou transférer de l’énergie, les contacts doivent être détectés et traités. \\

C’est ici qu’intervient le système de \textbf{colliders}, qui permet d’optimiser la détection des interactions en simplifiant la géométrie des objets. Plutôt que d’effectuer des calculs coûteux, chaque entité est associée à un volume géométrique simple (cercle ou rectangle), c'est un compromis entre coût de calcul et précision: 
\begin{itemize}
    \item \textbf{Cercles} pour les éléments arrondis (tonneaux, ennemis, joueur).
    \item \textbf{Rectangles} pour les structures angulaire (caisses, murs).
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\linewidth]{./img/debugCollider.png}
    \caption{Visualisation des colliders (en rouge) sur différentes entités}
    \label{fig:colliders_exemple}
\end{figure}

\paragraph{Modélisation du joueur}
Le joueur, initialement modélisé par un rectangle de \(16 \times 16\)~px, a été remplacé par un cercle de \(16\)~px de diamètre. Cette modification~: Procure une sensation de mouvement plus naturelle au joueur.

\subsubsection{Algorithme de detections des collisions}
Pour détectée les contact entre deux \textbf{colliders}, nous avons accès à deux algorithmes (cercle-rectangle et cercle-cercle). Ces derniers nous renvoies certaines valeurs nécessaires pour la gérer les collisions:
\begin{itemize}
\item \textbf{Profondeur de pénétration} (\textit{depth}) : mesure la distance de chevauchement entre les objets.
\item \textbf{Normale de collision (\(\vec{n}\))} : définit la direction dans laquelle appliquer la correction pour les séparer.
\end{itemize}

Soit un cercle de centre \((x_c, y_c)\) et de rayon \(r_c\), et un rectangle défini par son coin supérieur gauche \((x_r, y_r)\), sa largeur \(w_r\) et de hauteur \(h_r\), alors les algorithmes suivant s'appliquent :

\noindent
\begin{minipage}[t]{0.48\textwidth}
\subparagraph*{\underline{\small\textbf{Cercle-Rectangle}}}
\begin{enumerate}[leftmargin=*,topsep=2pt,itemsep=2pt]
    \item Trouver le point du rectangle le plus proche du centre du cercle : 
    \[
    \begin{cases} 
        x_p = \max(x_r, \min(x_c, x_r + w_r)), \\[2pt]
        y_p = \max(y_r, \min(y_c, y_r + h_r)).
    \end{cases}
    \]
    \item Mesurer la distance\(^2\) entre le cercle et le point proche :  
    \[
    d^2 = (x_c - x_p)^2 + (y_c - y_p)^2
    \]
    \item La collision à lieu si  :  
    \[
    d^2 < r_c^2
    \]
    \item Valeur de résolution :  
    \[
    \boxed{
        \begin{aligned}
            \text{depth} &= r_c - d, \\[2pt]
            \vec{n} &= \dfrac{(x_c - x_p,\ y_c - y_p)}{d}
        \end{aligned}
    }
    \]
\end{enumerate}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
\subparagraph*{\underline{\small\textbf{Cercle-Cercle}}}
\begin{enumerate}[leftmargin=*,topsep=2pt,itemsep=2pt]
    \item Mesurer la distance\(^2\) entre les centres des deux cercles :  
    \[
    d^2 = (x_2 - x_1)^2 + (y_2 - y_1)^2
    \]
    \item La collision à lieu si :  
    \[
    d^2 < (r_1 + r_2)^2
    \]
    \item Valeur de résolution : 
    \[
    \boxed{
        \begin{aligned}
            \text{depth} &= (r_1 + r_2) - d, \\[2pt]
            \vec{n} &= \dfrac{(x_2 - x_1,\ y_2 - y_1)}{d}
        \end{aligned}
    }
    \]
\end{enumerate}
\end{minipage}

\paragraph{Optimisation avec les distances au carré}
\label{sec:optimisation}
Pour accélérer la détection des collisions, nous utilisons les distances au carré, évitant ainsi le calcul coûteux de \texttt{sqrt}. En effet, la condition \(d^2 < r^2\) est équivalente à \(d < r\).

La distance classique entre deux points \((x_1, y_1)\) et \((x_2, y_2)\) est donnée par :
\[
d = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}
\]
Nous calculons plutôt :
\[
d^2 = (x_2 - x_1)^2 + (y_2 - y_1)^2
\]
Cette approche suffit pour la majorité des cas (absence de collision). Si une collision est détectée, le calcul de la racine reste nécessaire, mais le gain de temps est conséquent (\textit{voir Fig. en annexe \ref{fig:algoComparaison}}).

\subsubsection{Résolution des collisions}
\label{sec:resolution_collisions}
Une fois la collision détectée (et les valeurs de \textbf{depth} et de \textbf{normale} calculées), il convient de \textbf{résoudre} la collision, c’est-à-dire de \textbf{corriger} la position des entités pour qu’elles ne se superposent plus et de \textbf{mettre à jour leurs vitesses} afin de simuler un rebond (ou tout autre effet physique souhaité).

\paragraph{Étapes générales de la résolution}
Lorsque deux objets entrent en collision selon les algorithmes précédemment décrits, nous procédons en deux temps :
\begin{enumerate}
    \item \textbf{Correction de la position}: Pour supprimer la pénétration de longueur \(\text{Depth}\) le long de la normale \(\vec{n}\), on ajuste les positions \(\text{pos}_1\) et \(\text{pos}_2\) proportionnellement aux masses des deux entitées~:
    \[
    \text{pos}_1 \gets \text{pos}_1 + \frac{\text{mass}_2}{\text{mass}_1 + \text{mass}_2} \times \text{Depth} \times\vec{n}, \quad
    \text{pos}_2 \gets \text{pos}_2 - \frac{\text{mass}_1}{\text{mass}_1 + \text{mass}_2} \times \text{Depth} \times \vec{n}
    \]

    \textbf{Cas statique (\(\text{mass}_2 \to +\infty\))} : 
    Lorsque l'objet \(m_2\) est considéré comme une surface fixe (comme un mur), il ne se déplace pas. L'ajustement de la position concerne uniquement l'objet \(m_1\).
    \[
    \text{pos}_1 \gets \text{pos}_1 +  \text{Depth} \times \vec{n}, \quad \text{pos}_2 \gets \text{pos}_2 - 0
    \]

    \item \textbf{Calcul et application de l’impulsion} : Dans le cas d’un choc, on calcule l'\textbf{impulsion} qui simulera la \textit{réaction élastique}. Cette impulsion dépend de la \texttt{vitesse}, de la \texttt{masse} et de la \texttt{restitution} (élasticité) de chaque entité.
    \begin{itemize}
        \item On commence par déterminer la \textbf{vitesse relative} \(\vec{v}_{\text{rel}}\), qui est la différence entre les vitesses \(\vec{v}_2\) et \(\vec{v}_1\) des deux objets :
        \[
        \vec{v}_{\text{rel}} \gets \vec{v}_2 - \vec{v}_1
        \]
        \item Ensuite, on calcule l'\textbf{impulsion effective} \(I\), qui modélise la réaction entre les deux objets lors de la collision. Cette impulsion dépend de la vitesse relative, des masses des objets et de leur restitution \(e\). Le coefficient de restitution \(e\) est la moyenne des coefficients \(e_1\) et \(e_2\) des deux objets :
        \[
        e \gets \frac{e_1 + e_2}{2}
        \]
        L'impulsion \(I\) est ensuite calculée à l'aide de la formule suivante :
        \[
        I \gets \frac{-(1 + e) \left( \vec{v}_{\text{rel}} \cdot \vec{n} \right)}{\dfrac{1}{\text{mass}_1} + \dfrac{1}{\text{mass}_2}}
        \]
        \item Enfin, on applique l'impulsion \(I\) aux deux objets pour mettre à jour leurs vitesses. L'impulsion est répartie entre les deux objets en fonction de leurs masses respectives :
        \[
        \vec{v}_1 \gets \vec{v}_1 + \frac{I}{\text{mass}_1} \, \vec{n}, \quad \vec{v}_2 \gets \vec{v}_2 - \frac{I}{\text{mass}_2} \, \vec{n}
        \]
        La vitesse de chaque objet est ajustée en fonction de l'impulsion \(I\) dans la direction de la normale \(\vec{n}\).
    \end{itemize}
\end{enumerate}

\paragraph{Exemple : mur + slime + fantôme}
Un \texttt{slime} projeté contre un mur voit d'abord son \textit{collider} corrigée pour sortir du mur. Ensuite, s’il rebondit et percute un autre \texttt{slime}, une nouvelle correction accompagnée de l'application d'une impulsion s'opère. Enfin, si dans la foulée un \texttt{fantôme} entre en contact avec les deux slimes, le moteur résout ces collisions \textbf{indépendamment} à chaque frame au sein de la même boucle de simulation.

\paragraph{Limitations :}
Même si le système fonctionne, il a encore quelques points faibles :
\begin{itemize}
    \item Il ne prend pas en compte les frottements latéraux, ce qui rend les rebonds et les glissades moins réalistes.
    \item Le modèle de perte ou de restitution d'énergie est simplifié, sans détails comme l’angle du choc ou un amortissement progressif.
    \item Lorsqu’il y a collision entre deux objets mobiles, seule la position de l’un d’eux est corrigée.
\end{itemize}

\subsubsection{Le \textit{deltaTime}}
Le \textit{deltaTime} (\(\Delta t\)) est le temps écoulé entre deux frames. Il se calcule en soustrayant le temps de la frame précédente du temps actuel, puis en convertissant en secondes. Ce paramètre est essentiel pour rendre la simulation indépendante du taux de rafraîchissement. Il permet de mettre à jour les positions des entités de façon cohérente, en multipliant leur vitesse par \(\Delta t\).

\paragraph{Limites liées à une chute importante du \textit{deltaTime}}
Quand les FPS chutent brusquement, \(\Delta t\) devient très grand. Un \(\Delta t\) trop élevé peut entraîner des déplacements anormaux ou des disparitions d’entités. Cela perturbe la mise à jour des positions et la gestion des collisions dans le moteur physique, ce qui peut causer des comportements irréalistes ou même déstabiliser la simulation.

\subsubsection{Bilan}
La \textbf{résolution de collisions} \textbf{après} la \textbf{détection} constitue le \textbf{cœur} du comportement \og physique \fg{} du jeu. Grâce à cet enchaînement~:
\begin{itemize}
    \item \textbf{Détection} (algorithmes Cercle-Cercle / Cercle-Rectangle) + \textbf{Normale} + \textbf{Depth}.
    \item \textbf{Correction de position} (pour annuler la pénétration).
    \item \textbf{Calcul et application de l’impulsion} (rebonds, transfert d’énergie).
\end{itemize}
On obtient donc un système \textbf{relativement simple} mais qui \textbf{généralise} la plupart des interactions nécessaires : coups, poussées, glissades, etc.

\subsection{Le système d'intelligence artificielle des ennemis}

\subsection{Système des ennemis}

\subsubsection{Pourquoi un système modulaire ?}
\label{sec:systeme_modulaire}

Dans un \textit{rogue-like}, les ennemis sont essentiels pour la dynamique du gameplay. Chaque ennemi doit offrir une expérience unique tout en s’intégrant harmonieusement dans le moteur de jeu. Coder chaque ennemi individuellement rendrait le système rigide et difficile à maintenir.  
Pour éviter cela, nous avons adopté un \textbf{système modulaire}, où tous les ennemis partagent une base commune, tout en permettant des comportements spécifiques via des extensions.

\subsubsection{Structure commune des ennemis}
\label{sec:structure_commune}

Tous les ennemis héritent d’une structure de base (\texttt{t\_enemy}), contenant les éléments essentiels à leur gestion :
\begin{itemize}
    \item \texttt{entity} : Gère la position, les collisions et les animations.
    \item \texttt{health} : Contient les points de vie, l’invincibilité et les callbacks de mort.
    \item \texttt{xpReward} : Définit les points d’expérience donnés au joueur à la mort de l’ennemi.
\end{itemize}

Cette structure permet une manipulation uniforme des ennemis dans le moteur de jeu, tout en autorisant des comportements spécifiques à chaque type d’ennemi.

\subsubsection{Machines à états finis (FSM)}
\label{sec:fsm}

Chaque ennemi utilise une \textbf{machine à états finis} (FSM) pour gérer son comportement. Ce modèle permet de définir des états (\texttt{IDLE}, \texttt{CHASE\_PLAYER}, \texttt{ATTACK}) et des transitions entre eux selon les conditions du jeu.

\paragraph{Exemple : Slime}  
Le \texttt{Slime} utilise une FSM simple avec les états suivants :
\begin{itemize}
    \item \texttt{IDLE} : Immobile.
    \item \texttt{PATROL} : Déplacement aléatoire.
    \item \texttt{CHASE\_PLAYER} : Poursuite du joueur.
    \item \texttt{CHASE\_LAST\_KNOWN} : Recherche la dernière position connue du joueur.
\end{itemize}

\paragraph{Exemple : Boss Slime}  
Le \texttt{Boss Slime} possède une FSM plus avancée, intégrant des phases de combat (\texttt{PHASE1}, \texttt{PHASE2}, \texttt{PHASE3}) et des attaques spécifiques (\texttt{GROUND\_POUND}, \texttt{CHARGE\_ATTACK}).

\subsubsection{Exemples d’ennemis}
\label{sec:exemples_ennemis}

\paragraph{Slime : Ennemi de base}  
Le \texttt{Slime} est un ennemi simple apparaissant en grand nombre. Il se déplace par bonds successifs et alterne entre patrouille, poursuite et recherche de la dernière position connue du joueur.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.50\linewidth]{img/slimeFSM.png}
    \caption{Schéma de décision du Slime}
    \label{fig:slime_fsm}
\end{figure}

\paragraph{Fantôme : Ennemi imprévisible}  
Le \texttt{Fantôme} se démarque par ses mouvements ondulatoires et sa capacité à orbiter autour du joueur. Il peut activer un mode \texttt{BOOST} pour accélérer et devenir plus difficile à esquiver.

\begin{figure}[h]
    \centering
    \includegraphics[width=1.12\linewidth]{img/ghostFSM.png}
    \caption{Schéma de décision du Fantôme}
    \label{fig:ghost_fsm}
\end{figure}

\paragraph{Boss Slime : Ennemi complexe}  
Le \texttt{Boss Slime} est un ennemi multi-phases, dont les attaques évoluent en fonction de sa santé. Il utilise des attaques spéciales comme :
\begin{itemize}
    \item \texttt{GROUND\_POUND} : Onde de choc au sol.
    \item \texttt{CHARGE\_ATTACK} : Charge rapide vers le joueur.
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.75\linewidth]{img/bossFSM.png}
    \caption{Schéma de décision du Boss Slime}
    \label{fig:boss_fsm}
\end{figure}

\subsubsection{Bilan}
\label{sec:bilan_ennemis}

Grâce à une structure commune et aux FSM, notre système est à la fois \textbf{modulaire} et \textbf{extensible}. De nouveaux ennemis peuvent être ajoutés ou modifiés sans impacter les autres, tout en garantissant des comportements variés et cohérents. Ce design simplifie la maintenance et améliore l’expérience de jeu.









\subsection{Le cycle de jeu}

Lorsqu'on lance le jeu, le programme génère un niveau et les salles de celui-ci en fonction du niveau de difficulté choisi par le joueur : 
\begin{itemize}
    \item easy : 7 salles avec 5 monstres par salles
    \item normal : 17 salles avec 10 monstres pas salles
    \item hard : 22 salles avec 20 enemis par salles
    \item demonic : 32 salles avec 30 enemis par salles
    \item legendaire : 102 salles avec 50 enemis par salle
\end{itemize}
Puis, quand le joueur clique sur le bouton jouer, le programme va générer les salles demandées, ce qui crée un petit temps d'attente si le joueur décide de jouer en mode légendaire.
Nous avons préféré que le joueur attende en début de partie plutôt que d'avoir de la latence quand il change de map car il faut la créer.
Une fois les cartes générées, il est placé aléatoirement sur la première. Le but du joueur : tuer les monstres des différentes salles pour pouvoir passer à la prochaine, 
Trouver des équipements grâce aux coffres et au marchand  est donc essentiel  pour aller se battre contre le boss du jeu et le tuer.
Le joueur commence son aventure avec un simple couteau, mais il sera possible pour lui de changer d'arme et d'améliorer son inventaire pour pouvoir jouer comme il le veut. Puisque les salles, boss et items sont aléatoires, une partie est unique
\\\\
Pour résumer : 
\begin{figure}[h] 
    \centering 
    \includegraphics[width=0.4\linewidth]{./img/cycle.png} 
    \caption{le cycle de jeu} 
\end{figure} 

\section{Bilan et conclusions}

Lo Poti Donjon reflète notre vision d'un jeu dynamique, où chaque partie offre une expérience différente et imprévisible, tout en maintenant un bon équilibre entre facilité et challenge. Nous sommes curieux de voir comment le projet va évoluer et quel impact il pourra avoir sur les joueurs.

\section{Annexes}

\subsection{Exemple de débogage : Gestion des pointeurs \texttt{NULL} selon le système d'exploitation}
\subsubsection{Contexte du problème}
Lors de l'exécution du programme, une \textbf{erreur de segmentation} a été observée. Curieusement, ce comportement ne se manifestait que sur certaines machines de l'équipe, tandis que d'autres pouvaient exécuter le jeux sans problème. 
L'origine du bug etait dans la tentative de conversion d'un pointeur \texttt{NULL}, retourné par la fonction \texttt{getObject} pour un index invalide, en un pointeur d'un autre type

\subsubsection{Investigation initiale}
A force de test nous sommes arrivé à la conclusion que :
\begin{itemize} 
    \item Les paramètres d'entrée étaient vérifier, et non égale à \texttt{NULL}. 
    \item Deux éléments étaient suspectés d'être en cause : 
    \begin{itemize} \item La variable \texttt{salleDep} dans le contrôleur de scène 
    \item La structure de données \texttt{scene} 
    \end{itemize} 
\end{itemize}

\begin{figure}[h]
\centering
\includegraphics[width=0.8\textwidth]{./img/gdbSIGEGV.png}
\caption{Trace d'exécution dans GDB montrant le point de crash}
\label{fig:gdbSIGEGV}
\end{figure}

\newpage
L'analyse à l'aide de GDB a permis d'observer : 
\begin{itemize} 
    \item Une adresse mémoire non nulle (ex. \texttt{0x01}) pour \texttt{salleDep}, même dans le cas où \texttt{getObject} devait renvoyer \texttt{NULL}. 
    \item Une variation aléatoire de la valeur de \texttt{salleDep} entre différentes exécutions et machine (\textit{voir Fig. \ref{fig:gdb0x1}})
\end{itemize}

\begin{figure}[h]
\centering
\includegraphics[width=0.8\textwidth]{./img/gdb0xf0.png}
\caption{Sortie de \texttt{print salleDep} montrant une adresse invalide}
\label{fig:gdb0xf0}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.8\textwidth]{./img/gdb0x1.png}
\caption{Variation de la valeur de \texttt{salleDep} entre deux exécutions}
\label{fig:gdb0x1}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.8\textwidth]{./img/gdbNoError.png}
\caption{Comportement normal lorsque tout marche}
\label{fig:gdbNoError}
\end{figure}

\subsubsection{Origine du problème et correction du code}

\begin{lstlisting}[caption={Ligne fautive}, label=code:fautive]
t_scene* salleDep = (t_scene*)getObject(controller->scene, controller->currentScene);
\end{lstlisting}

Le problème venait de la tentative de conversion d'un pointeur \texttt{NULL}, retourné par la fonction \texttt{getObject} lorsqu'un indice invalide (Dans notre cas, \texttt{-1}) était utilisé.
Nous avons théorisé que en raison des différences d'initialisation de la mémoire entre systèmes d'exploitation, certains environnements interprétaient correctement ce retour comme étant \texttt{NULL}, tandis que d'autres ne le faisaient pas, générant ainsi des valeurs indéterminées (par exemple : \texttt{0x01}, \texttt{0xf0}), pouvant inclure \texttt{NULL}, ne facilitant pas le debuggage.


\subsection{Analyse de compléxité d' l'algorithme de detection des collisions}

\begin{figure}
    \centering
    \includegraphics[width=0.5\linewidth]{img/algoComparaison.png}
    \caption{Complexité moyenne de la détections de collision entre \(1\) et \(n\) objets}
    \label{fig:algoComparaison}
\end{figure}

Ce graphique montre combien de temps prend un test de collision entre une entité et $n$ autres. Dans le jeu, chaque entité est comparée à toutes les autres, donc le temps total de calcul est en $O(n^2)$. Le graphique, lui, montre seulement un test (entre 1 et $n$), donc un coût linéaire $O(n)$.

\subsubsection{Ce que montrent les courbes}

On a quatre courbes :
\begin{itemize}
    \item \textbf{Optimisé avec collisions (bleu)} : On utilise les distances au carré, mais il y a des collisions détectées, donc on calcule encore quelques racines carrées.
    \item \textbf{Optimisé sans collisions (vert)} : Même méthode, mais aucune collision n’est détectée, donc pas de racine carrée du tout.
    \item \textbf{Non optimisé avec collisions (rouge)} : À chaque test, on calcule une racine carrée, et on traite les collisions.
    \item \textbf{Non optimisé sans collisions (violet)} : On calcule la racine carrée, mais aucune collision détectée.
\end{itemize}


L’optimisation par distances au carré réduit significativement la constante de proportionnalité, mais ne change pas la complexité.

\subsubsection{Ce que ça change dans le jeu}

Comme chaque entité est comparée à toutes les autres, on a environ \(\frac{n(n-1)}{2}\) comparaisons. Donc si on gagne du temps sur une comparaison, ça se répercute partout. \\

D’après le graphique, on observe que l’optimisation divise le temps de calcul global par environ 30\% et 50\% selon s’il y a beaucoup de collisions ou non. Ce n’est pas négligeable quand $n$ devient grand.

\subsubsection{Limite de cette méthode}
Même avec l’optimisation, on reste en $O(n^2)$, donc si le nombre d’entités augmente significativement, ça finira par ralentir.
\subsubsection{Conclusion}
L’optimisation avec les distances au carré est simple à mettre en place et permet déjà un bon gain de performance. Mais elle ne suffit pas si on veut gérer beaucoup d’entités. Il faudra à terme utiliser une autre structure pour réduire le nombre de comparaisons.

\newpage


\subsection{Programme test}
Nous ne pouvons pas tester chaque bout de code car certain sont fait pour exclusivment marché qvec d'autre nous avons choisi trois programme pouvant fonctionné de façon autonome : objectManager, fscene et genMap.

\subsubsection{Jeux de test}
\textit{cette partie traite des jeux de test effecuter pour le projet}

\subsubsection{Les test d'object Manager}
Puisque l'object manager est centralisé pour fonctionner avec les autres alors il nous semble naturelle de comencé les teste par lui.
Nous allons donc testé c'est fonction de création, d'ajout, de supression, de récuperation ainsi que de destruction\\

\begin{table}[h]
\centering
\begin{tabular}{|c|c|}
\hline
\textbf{Nom de la fonction de test} & \textbf{Objectif du test}\\
\hline
test\_createTypeRegistry() & tester la création d'un registre de type \\
\hline
test\_registerType() & tester l'ajout d'un type dans le registre \\
\hline
test\_initObjectManager()& tester la création et l'initialisation d'un objectManager \\
\hline
test\_addObject()& tester l'ajout d'un élement dans l'objectManager \\
\hline
test\_addObjects\_SameType() & tester l'ajout de plusieurs élements de même type dans l'objectManager \\
\hline
test\_addObject\_DifferentsType() &  tester l'ajout de plusieurs élements de  types différents\\& dans l'objectManager\\
\hline
test\_deleteObject() & tester la supression d'un object de l'objectManager\\
\hline
test\_freeObjectManager() & teste de destruction de l'objectManager\\
\hline



\end{tabular}
\end{table}
\vspace{-5mm}
\bigskip
\subsubsection{Les tests de fscene}
Les tests sur fscne nous permettens de faire un test d'integration avec l'object manager voici les fonction de test utilisée.\\
\begin{table}[h]
\centering
\begin{tabular}{|c|c|}
\hline
\textbf{Nom de la fonction de test} & \textbf{Objectif du test}\\
\hline
test\_createScene() & tester la création d'une scène \\
\hline
test\_sceneAddObject() & tester l'ajout d'un object dans la scène \\
\hline
test\_sceneRemoveObject()& tester la supression d'un objet de la scène\\
\hline
test\_sceneRegisterFunction() & tester l'ajout d'une fonction dans la scène \\
\hline
test\_setScene()  & tester le changment de scène\\
\hline

\end{tabular}
\end{table}


\subsubsection{Les tests de GenMap}
Les tests sur GenMap nous permettens de faire un test unitaire pour la création d'un niveau, une partie essentiel au jeux.\\

\begin{table}[h]
\centering
\begin{tabular}{|c|c|}
\hline
\textbf{Nom de la fonction de test} & \textbf{Objectif du test}\\
\hline
test\_initRoom() & tester l'initialisation d'une salle\\
\hline
test\_connectRoom()  & tester la connexion de plusieurs salle entre elles\\
\hline
test\_genMap()& tester la géneration d'une map (plusieurs salles connecté entre elles)\\
\hline
test\_freeLevel() & tester la supression d'un niveau\\
\hline
test\_setScene()  & tester le changment de scène\\
\hline

\end{tabular}
\end{table}


\subsection{Inventaire}

\begin{figure}[h]
    \centering 
    \includegraphics[width=0.75\linewidth]{./img/affichageStats.png} 
    \caption{affichage stats-description} 
    \label{fig:inventaire}
\end{figure}


\subscection{source}
Voici nos utilisé pour réaliser le projet : 
\begin{itemize}
    \item Visuelle : 
    \begin{itemize}
        \item tilesMap de keeny (libres de droit) : \url{https://kenney-assets.itch.io/tiny-dungeon}
        \item font d'écriture 1 : \url{https://www.jetbrains.com/lp/mono/}
        \item font d'écriture 1 : \url{https://www.zone38.net/font/}
    \end{itemize}
    \item ObjectManager : 
    \begin{itemize}
        \item \url{https://peerdh.com/blogs/programming-insights/memory-pool-management-techniques-in-c}
        \item \url{https://en.wikipedia.org/wiki/Memory_pool}
        \item \url{https://8dcc.github.io/programming/pool-allocator.html}
    \end{itemize}
    \item systeme de combat : \url{https://www.youtube.com/watch?v=8X4fx-YncqA}
    \item Perlin noise :
    \begin{itemize}
        \item \url{https://thebookofshaders.com/11/?lan=fr}
        \item \url{https://fr.wikipedia.org/wiki/Bruit_de_Perlin.}
    \end{itemize}
    \item membre honorifique : Loup Picault le développeur python, voici son site web \url{https://raeptor.com/}
    
    
\end{itemize}



\end{document}