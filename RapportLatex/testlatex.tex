\documentclass[a4paper,11pt]{article}

\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage{color}
\usepackage{microtype}
\usepackage{graphicx}
\usepackage{booktabs}  % For better tables
\usepackage{enumitem}  % For better lists
\usepackage{hyperref}  % For clickable links in PDF
\usepackage{amsmath}  % Pour les équations

\usepackage{listings}

\lstset{
    language=C,
    basicstyle=\ttfamily\small,           
    frame=single,
    breaklines=true,                       
}

\hypersetup{colorlinks=true,linkcolor=blue,urlcolor=red,citecolor=green}


\pagestyle{fancy}
\setlength{\headheight}{29pt}

\usepackage{titlesec}


\lhead{\includegraphics[width=2cm]{./img/image.png}}
\rhead{\includegraphics[width=2cm]{./img/claude.png}}

\begin{document}

\title{\huge{\textbf{\textcolor{blue}{Lo Poti Donjon}}}}
\author{\Large{Ubissauphte}}
\date{\today}
\maketitle
\newpage
\tableofcontents
\newpage

\section{Introduction}
\subsection{Contexte du projet}
\subsection{Présentation du projet}

\textbf{Lo Poti Donjon} est un projet ambitieux que nous, Ubissauphte, avons lancé le 13 janvier 2025. Initialement, nous envisagions de créer 
un jeu de bataille navale en ligne. Cependant, après plusieurs réunions au sein du groupe, nous avons décidé de revoir notre approche. 

L'idée de créer un jeu plus complexe avec une patte graphique plus importante a vraiment stimulé notre créativité.

Nous avons donc décidé de créer un jeu roguelike, un sous-genre de jeu de rôle où le joueur explore 
un donjon rempli de monstres qu'il doit combattre pour gagner de l'expérience et des trésors. Notre jeu présente certains avantages et défauts :

\begin{center}
\begin{tabular}{p{5cm}|p{5cm}}
\toprule
\textbf{Avantages} & \textbf{Inconvénients} \\
\midrule
Facile d'accès & Potentiellement addictif \\
Permissif & Aspects punitifs \\
Fluidité optimisée & \\
Portage sur diverses machines & \\
Évolution constante du personnage & \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Conception}
\newpage

\section{Organisation du projet}
\textit{Cette partie traite des moyens organisationnels mis en œuvre permettant la réalisation du projet.}

\subsection{Répartition des tâches}

Concernant la répartition des tâches, nous nous sommes appuyés sur les qualités de chacun pour avancer rapidement et efficacement :

\begin{itemize}[leftmargin=*]
  \item \textbf{Victore Fombertasse} a réalisé les animations du jeu ainsi que l'audio et la création de la structure d'un niveau.
  
  \item \textbf{Souleymane Barry} a créé le système d'inventaires, celui de sauvegarde ainsi que le prototype du système de déplacement du joueur.
  
  \item \textbf{Baptiste Carfantan} a conçu les salles générées procéduralement ainsi que la boucle de gameplay pour progresser dans le jeu.
  
  \item \textbf{Barthélemy Deroualt}, chef de projet, s'est chargé de la gestion des systèmes liés aux ennemis, au joueur, aux événements ainsi qu'à la physique du jeu.
\end{itemize}

Nous avons également réalisé des tâches en groupe, que ce soit pour intégrer les codes au programme principal ou pour traiter des problèmes suffisamment complexes nécessitant la participation de plusieurs personnes. Nous avons par exemple développé des systèmes de simplification de code, appelés « managers », permettant à chaque membre de l'équipe d'utiliser les fonctionnalités sans avoir besoin de comprendre entièrement le code des autres.

\subsection{Planning prévisionnel}

\subsection{Outils de travail}

\section{Développement}

\subsection{Génération aléatoire du donjon}

\subsection{Gestion des items}

\subsection{Le moteur physique}

\subsubsection{Pourquoi un moteur physique ?}
\label{sec:moteur_physique}

Dans un jeu vidéo, et particulièrement dans un \textbf{rogue-like}, les interactions entre éléments (personnages, ennemis, objets) posent un défi de taille~: l'imprévisibilité des combinaisons de collisions. 

Les mouvements, les collisions, les rebonds et autres effets physiques doivent être simulés de manière réaliste pour ne pas gâcher l’expérience du joueur. Cependant, un système simplifié, où chaque interaction serait codée manuellement, devient rapidement ingérable, la solution que nous avons donc trouver est celle d'un \textbf{moteur physique}, permettant de gérer de manière automatisée toutes ces interactions.


\subsubsection{Gestion des collisions par colliders} 
\label{sec:colliders}
La détection des collisions repose sur une abstraction géométrique des entités. Plutôt que de calculer les intersections \textit{pixel par pixel} -- méthode particulièrement coûteuse en ressources -- chaque élément est associé à un volume primitif. Cette approche répond à trois exigences fondamentales du projet~:

\begin{itemize}
    \item Maintenir un coût de calcul raisonnable.
    \item Garantir des comportements physiques prévisibles.
    \item Faciliter l'extension du système par modularité.
\end{itemize}

\paragraph{Implémentation technique} 
Chaque entité se voit attribuer un composant physique optionnel accompagné d'une forme primitive adaptée à sa nature~:
\begin{itemize}
    \item \textbf{Cercles} pour les éléments arrondis (tonneaux, ennemis, joueur).
    \item \textbf{Rectangles} pour les structures angulaires (caisses, murs).
\end{itemize}
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.75\linewidth]{./img/debugCollider.png}
    \caption{Visualisation des colliders (en rouge) sur différentes entités}
    \label{fig:colliders_exemple}
\end{figure}

\paragraph{Exemple d'utilisation} 
Le joueur, initialement modélisé par un rectangle de \(16 \times 16\)~px, a été remplacé par un cercle de \(16\)~px de diamètre. Cette modification~:
\begin{itemize}
    \item Procure une sensation de mouvement plus naturelle.
    \item Permet un glissement le long des surfaces.
    \item Génère des rebonds cohérents dans les coins.
\end{itemize}



\paragraph{Exemple d'interaction}  
Lorsqu’un Slime (léger et élastique) est frappé par le joueur, une force orientée selon l’angle de l’attaque lui est appliquée. Projeté contre un Orc (lourd), le moteur calcule automatiquement la réaction : l’Orc subit un léger recul, tandis que le Slime rebondit en changeant de direction. Si le Slime percute ensuite un mur, son élasticité réduit progressivement l’énergie du rebond. Enfin, il peut se cogner contre un autre slime, et lui transmettre encore de l’énergie. Ces interactions en cascade émergent naturellement des lois physiques configurées, sans nécessiter de code spécifique.

\paragraph{Avantages}  
Ce système réduit significativement la complexité du code. Par exemple, une épée qui repousse un ennemi utilise la même logique qu’un projectile ricochant sur un mur, grâce aux paramètres centralisés. Il offre également une extensibilité aisée : ajouter une entité (comme un projectile) se limite à définir ses constantes physiques.

\subsection{Les ennemis}

\subsection{Le cycle de jeu}

\section{Bilan et conclusions}

\section{Annexes}

\subsection{Exemple de débogage : Gestion des pointeurs \texttt{NULL} selon le système d'exploitation}
\subsubsection{Contexte du problème}
Lors de l'exécution du programme, une \textbf{erreur de segmentation} a été observée. Curieusement, ce comportement ne se manifestait que sur certaines machines de l'équipe, tandis que d'autres pouvaient exécuter le jeux sans problème. 
L'origine du bug etait dans la tentative de conversion d'un pointeur \texttt{NULL}, retourné par la fonction \texttt{getObject} pour un index invalide, en un pointeur d'un autre type

\subsubsection{Investigation initiale}
A force de test nous sommes arrivé à la conclusion que :
\begin{itemize} 
    \item Les paramètres d'entrée étaient vérifier, et non égale à \texttt{NULL}. 
    \item Deux éléments étaient suspectés d'être en cause : 
    \begin{itemize} \item La variable \texttt{salleDep} dans le contrôleur de scène 
    \item La structure de données \texttt{scene} 
    \end{itemize} 
\end{itemize}

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{./img/gdbSIGEGV.png}
\caption{Trace d'exécution dans GDB montrant le point de crash}
\label{fig:gdbSIGEGV}
\end{figure}

\newpage
L'analyse à l'aide de GDB a permis d'observer : 
\begin{itemize} 
    \item Une adresse mémoire non nulle (ex. \texttt{0x01}) pour \texttt{salleDep}, même dans le cas où \texttt{getObject} devait renvoyer \texttt{NULL}. 
    \item Une variation aléatoire de la valeur de \texttt{salleDep} entre différentes exécutions et machine (\textit{voir Fig. \ref{fig:gdb0x1}})
\end{itemize}

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{./img/gdb0xf0.png}
\caption{Sortie de \texttt{print salleDep} montrant une adresse invalide}
\label{fig:gdb0xf0}
\end{figure}

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{./img/gdb0x1.png}
\caption{Variation de la valeur de \texttt{salleDep} entre deux exécutions}
\label{fig:gdb0x1}
\end{figure}

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{./img/gdbNoError.png}
\caption{Comportement normal lorsque tout marche}
\label{fig:gdbNoError}
\end{figure}

\subsubsection{Origine du problème et correction du code}

\begin{lstlisting}[caption={Ligne fautive}, label=code:fautive]
t_scene* salleDep = (t_scene*)getObject(controller->scene, controller->currentScene);
\end{lstlisting}

Le problème venait de la tentative de conversion d'un pointeur \texttt{NULL}, retourné par la fonction \texttt{getObject} lorsqu'un indice invalide (Dans notre cas, \texttt{-1}) était utilisé.
Nous avons théorisé que en raison des différences d'initialisation de la mémoire entre systèmes d'exploitation, certains environnements interprétaient correctement ce retour comme étant \texttt{NULL}, tandis que d'autres ne le faisaient pas, générant ainsi des valeurs indéterminées (par exemple : \texttt{0x01}, \texttt{0xf0}), pouvant inclure \texttt{NULL}, ne facilitant pas le debuggage.

\end{document}